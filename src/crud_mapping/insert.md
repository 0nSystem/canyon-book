# INSERT operations

Now it's time for write some data to the database.

`Canyon` provides you a nice and neat way to insert data. Directly from an instanciated object.

Remeber this?

```rust
#[derive(CanyonCrud, CanyonMapper)]
#[canyon_entity]
pub struct League {
    #[primary_key]
    pub id: i32,
    pub ext_id: i64,
    pub slug: String,
    pub name: String,
    pub region: String,
    pub image_url: String
}
```

Let's create a `League` instance:

```rust
let mut lec: League = League {
    id: Default::default(),
    ext_id: 134524353253,
    slug: "LEC".to_string(),
    name: "League Europe Champions".to_string(),
    region: "EU West".to_string(),
    image_url: "https://lec.eu".to_string(),
};
```

Now, we will write the following `Rust` code, considering our example type:
`lec.insert().await;`

*BOOM!* And that record it's now inserted on the database!

But notate one thing. Our `lec` instance now it's a `mut` one. Why?

The key thing on the `insert` method it's that `Canyon` automatically will update your `self.id` field with the new generated id after the insert! So, the next time that you will access the `id` field to retrieve it's value, there will be the real one!

The `insert method` it's really convenient and nice when you have to write data to your database.

For example, one common scenario. You make a call to an external service, parses the data into a new instance of your `Rust` type (with for example, some Serde serialization code), and now you can insert it directly, with one expresion!

## The new associated function pattern

One common alternative for write better and mantainable code, w'd be use the convention about *"constructors"* in `Rust`.

Even that there's no such exact concept in the language, a convention was made to create and initialize new instances for a `T` type.

This convection it's to write a `::new(params)` *associated function* to initialize new objects in the `impl` block for your type. Then, we can take advantage of that aproach, and write such an associated function omitting the `id` field and assign it a default value inside the function, so the details of the initializacion are now *encapsulated* inside that piece of code.

```rust
impl League {
    pub fn new(
        ext_id: i64,
        slug: String,
        name: String,
        region: String,
        image_url: String
    ) -> Self {
        Self {
            id: Default::default(),
            ext_id: ext_id,
            slug: slug,
            name: name,
            region: region,
            image_url: image_url
        }
    }
}
```

So, with this in mind, we can refactor our initialization and write it like the following:

```rust
let lec: League = League::new(
    134524353253,
    "LEC".to_string(),
    "League Europe Champions".to_string(),
    "EU West".to_string(),
    image_url: "https://lec.eu".to_string()
);
```

and just insert the new generated data:
`lec.insert().await;`

It returns a `Result<(), Err>`. Note that, for simplicity, we are omiting handling results.

## The multiple insert

`Canyon` also allows you to make the insert of multiple entities in just one operation.
The multi insert isn't designed as a method of your type `T`, but as an associated function.

You can pass instances to a reference to a raw Rust array, and await the result. The autogenerated values for the declared fields as primary key will be placed in that field for every instance.

The syntax it's a little bit more complicated, althought not too much. Here's an example:

```rust
/// Demonstration on how to perform an insert of multiple items on a table
async fn _multi_insert_example() {
    let new_league = League {
        id: Default::default(),
        ext_id: 392489032,
        slug: "DKC".to_owned(),
        name: "Denmark Competitive".to_owned(),
        region: "Denmark".to_owned(),
        image_url: "https://www.an_url.com".to_owned()
    };
    let new_league2 = League {
        id: Default::default(),
        ext_id: 392489032,
        slug: "IreL".to_owned(),
        name: "Ireland ERL".to_owned(),
        region: "Ireland".to_owned(),
        image_url: "https://www.yet_another_url.com".to_owned()
    };
    let new_league3 = League {
        id: Default::default(),
        ext_id: 9687392489032,
        slug: "LEC".to_owned(),
        name: "League Europe Champions".to_owned(),
        region: "EU".to_owned(),
        image_url: "https://www.lag.com".to_owned()
    };

    // Unused Result<T, E>
    League::insert_into(
        &[new_league, new_league2, new_league3]
    ).await;
}
```

## #[primary_key] notes

As you may notice, having a `#[primary_key]` is mandatory if your database table contains one.
By default, `Canyon` omits the `PK` value on the insert operation, because assumes that there's a sequence or similar database concept in the column that holds the primary key, and the database is taking care of making a unique and autoincremental value.

However, you will be able to insert in tables that any of it's columns has a primary key. You just will need to not declare a `#[primary_key]` in your entity.

That's the reason why the `#[primary_key]` annotation is so important on the insert operations. If a column's table has a primary key, `Canyon` won't try to serialize the value for that column, and if there's no annotation, `Canyon` will serialize it to insert it. Any other combination will make the insert operation fail, because we were trying to do an illegal or incomplete operation.

- Remeber that you have the `_datasource(datasource_name: &str)` alternatives.
- Remember that, if you don't provide a `#[primary_key]` operation, the *insert* methods won't be generated for your type! But the associated function `T::multi_insert()` will remain available.
