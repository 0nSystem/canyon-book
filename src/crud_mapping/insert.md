# INSERT operations

Now it's time for write data to the database. 

`Canyon` provides you a nice and neat way to insert data. Directly from an instanciated object.

```
NOTE: One particular thing in Canyon it's to deal with the id field. Every struct, at least for now, 
must have a field `id: i32` or `id: i64`
```

Remeber this?
```
#[derive(Debug, Clone, CanyonCrud, CanyonMapper)]
pub struct League {
    pub id: i32,
    pub ext_id: i64,
    pub slug: String,
    pub name: String,
    pub region: String,
    pub image_url: String
}

```

Let's create a `League` instance:

```
let lec: League = League {
    id: Default::default(),
    ext_id: 134524353253,
    slug: "LEC".to_string(),
    name: "League Europe Champions".to_string(),
    region: "EU West".to_string(),
    image_url: "https://lec.eu".to_string(),
};
```

Now, we will write the following `Rust` code, considering our example type:
`lec.insert().await;`

*BOOM!* And that record it's now inserted on the database!

The `insert method` it's really convenient and nice when you have to write data to your database.

One common scenario was already discussed before. 
You make a call to an external service, parse the data into a new instance of your `Rust` type, 
and now you can insert it directly, with one expresion!

You may be wondering about the `id` field. Let's dive in.

By default, every `insert` operation in Canyon it's made supposing that the `PRIMARY KEY`
for your database it's by default `autogenerated` and `autoincremental`.

We won't reach advanced topics where `Canyon` creates and mantains your tables directly,
but it will be our reaching point at the end of the next chapters, so we must assume for
now that, when you create your table, the `id` column it's `GENERATED ALWAYS AS IDENTITY`
for `PostreSQL` or similar for another database engines that will be supported nearly 
in the future.


### The instanciation default value

One *not to ugly* workaround when you use the syntax above to create a new instance for `League`,
it's to use de `Default::default` Rust trait, which will generate a default value based on the
type of the field where it's declared.

We can, for sure, use directly an `i32` in this case, but the reallity is that `Canyon` will
discard whatever value you putted there in every insert operation, so you code will have a
value that isn't corresponding with the reality, and the code could lead to potencial
missleading reading it, because anybody w'd be thinking that the insert was a choosen
value for the user, and that's not true folks!


### The new associated function to the rescue

Another prefered alternative for write better and mantainable code, w'd be use the convention
about *constructors* in `Rust`

Even that there's no such concept in the language, a convention was made to initialize new
instances for a `T` type.

This convection it's to write a `::new(params)` *associated function* to initialize new
objects in the `impl` block for your type. Then, we can take advantage of that aproach,
and write such an associated function omitting the `id` field and assign it a default
value inside the function, so the details of the initializacion are now *encapsulated*
inside that piece of code.

```
NOTE: Don't get confused with the ext_id field. This it's just an arbitrary number representing
some sort of hash or identification inside it's data. Isn't our database id!
```

```
impl League {
    pub fn new(
        ext_id: i64,
        slug: String,
        name: String,
        region: String,
        image_url: String
    ) -> Self {
        Self {
            id: Default::default,
            ext_id: ext_id,
            slug: slug,
            name: name,
            region: region,
            image_url: image_url
        }
    }
}
```

So, with this in mind, we can refactor our initialization and write it like the following:

```
let lec: League = League::new(
    134524353253, 
    "LEC".to_string(),
    "League Europe Champions".to_string(),
    "EU West".to_string(),
    image_url: "https://lec.eu".to_string()
);
```

and just insert the new generated data:
`lec.insert().await;`


## The multiple insert

`Canyon` also allows you to make the insert of multiple entities in just one operation.
The multi insert isn't designed as a method of your type T, but as an associated function.

You can pass instances to a reference to a raw Rust array, and await the result.

The syntax it's a little bit more complicated, althought not too much. Here's an example:

```
/// Demonstration on how to perform an insert of multiple items on a table
async fn _multi_insert_example() {
    let new_league = League {
        id: Default::default(),
        ext_id: 392489032,
        slug: "League10".to_owned(),
        name: "League10also".to_owned(),
        region: "Turkey".to_owned(),
        image_url: "https://www.sdklafjsd.com".to_owned()
    };
    let new_league2 = League {
        id: Default::default(),
        ext_id: 392489032,
        slug: "League11".to_owned(),
        name: "League11also".to_owned(),
        region: "LDASKJF".to_owned(),
        image_url: "https://www.sdklafjsd.com".to_owned()
    };
    let new_league3 = League {
        id: Default::default(),
        ext_id: 9687392489032,
        slug: "League3".to_owned(),
        name: "3League".to_owned(),
        region: "EU".to_owned(),
        image_url: "https://www.lag.com".to_owned()
    };

    League::insert_into(
        &[new_league, new_league2, new_league3]
    ).await;
}
```
