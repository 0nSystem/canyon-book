# Canyon Entity

Woo! Time to get serious!

We are gonna review one of the most powerful `Canyon` features. *The entities*


## What is a Canyon Entity?

You already see how, in the past chapters, we defined the concept of entity and
how it was used in a lot of contexts.

But in `Canyon` an *entity* still has a powerful meaning that the presented before.

Let's start simple. A `Canyon Entity` it's a user defined type, a struct, that
it's annotated with a really special `proc-macro`.

`#[canyon_entity]`

It looks like this attached to our `League` example for the past chapters:

```
use canyon_sql::*;

    #[canyon_macros::canyon_entity]
    pub struct League {
        pub id: i32,
        pub ext_id: i64,
        pub slug: String,
        pub name: String,
        pub region: String,
        pub image_url: String
}
```

*NOTE: WIth the wildcard import, you must define it's path as presented above*

This macro unlocks a set of new features to our type. Most are user-hidden, but
it will affect the way that your app interact with `Canyon` with features
that will be presented on the next chapters.

But, how this affect the developer? Why is so special?

This annotation makes two important things for you:

- Let to `Canyon` knows that you may desire that it should take care about
everything in your program related with this type.
- Generates two powerful enumerations to interact with a feature that
will be presented the next chapter: `The QueryBuilder`

Those only two things, are a really two big things. The implications behind
them are really huge for the upcoming lectures. But for now, let's gonna 
discuss the second point to discover something new about `Canyon` and
to prepare ourselves for the next chapter.

Usually, when working with `SQL`, there's a lot of places where you want to 
specify the column of the type of the column for some reason in some operation.
That's exactly what the autogeneration of this enums provides, a way of refer
to a database column, it's type or it's value in a procedural way, replacing
the string that you usually will put in that place to reference it for a
piece of valid `Rust` code. 

Ah, don't worry, `Canyon` already translates that procedures for the correspondent
identifiers whenever it needs it.

Let's now review those two beasts!

## The Field enum

The field enum it's an autogenerated enum, which main purpose it's to relate
every field of your type with a procedural way of reflecting them through the code.

It's identifier it's generated as the concatenation of your type's identifier
+ "Field".

*NOTE: There's an important convenction here in Canyon about the way on how the variants*
*are written. By default, variants of an enumeration in Rust are written in PascalCase form,*
*while in Canyon are written exactly the same on how the field it's written (convenction here*
*applies snake_case).*
*This is under review and discussion in the development team, and could be subscribed to nearly*
*future changes (or not).*

```
#[derive(Clone, Debug)]
#[allow(non_camel_case_types)]
pub enum LeagueField {
    id,
    ext_id,
    slug, 
    name, 
    region, 
    image_url
}

impl FieldIdentifier for LeagueField {}
```

In any place that you must specify a concrete column of the `league` table, for example, the
`slug` column, you will write `"slug"`. Any literal in the code it's error prone, since a lot of
bad things can go wrong with them, plus IDE's don't offer autocompletation of information about
them (we're not refering to the AI autocompletion tools, which are out of scope for this).

So now, you only need to type `LeagueField::slug`.

Yes, we know. "It's more code"... HA! But we removing a literal from our code, and potencially
every literal written in this situation. The IDE now will help us if we write a bad one, or 
autocompleting (God bless the `Ctrl + spacebar`).

Also, it's easier to detect a wrong variant. Even they are translated into literals, when used,
you can only put the wrong one and make a bad operation, but now you can't write a literal
that does not even exists and makes your code panic!

About the `impl FieldIdentifier for LeagueField {}` trait impl, does not take care.
It's just part of a `Canyon's` bound to know when it must accept a FieldIdentifier
type as an argument of the functions that generates the filters for the queries.
Just notice that exists, because it will be the requiered type for the next
upcoming operations, almost always are used when you generate some kind
of filter for your query in the `SQL` language. This is achieved in `Canyon`
thanks to the `QueryBuilder` that we will be reviewing in the next chapter.

Be patient, we're almost there!


# The FieldValue enum

In a complementary way to the `Field` enum, another one it's generated with the `canyon_entity`
proc-macro annotation. 

This new one it's known as the `FieldValue` enum, and represents the same as the `Field`
enum (a procedural way to determine to what field we are refering) but accepts a value
as an argument in every variant. That argument must be of the exact same type of
the field's type.

The main purpose of this enum, it's to make filters for an `SQL` query, where the
filter needs a value to perform the filtering. 

It looks like this:

```
#[derive(Clone, Debug)]
#[allow(non_camel_case_types)]
pub enum LeagueFieldValue {
    id(i32),
    ext_id(i64),
    slug(String), 
    name(String), 
    region(String), 
    image_url(String)
}

impl FieldIdentifierValue for LeagueFieldValue {}
```

It's just a powerful way of write filters for the `SQL` queries.

Imagine that we have a function that accepts a type `T: FieldValueIdentifier` to
make a `SQL where clause` filter.

It's signature will looks something similar to this:

`async fn find_by_id<F: FieldValueIdentifier>(fv: F, comp: Comp) -> Option<T>;`

*NOTE: The `Comp` enum type it's not relevant now, but it's the way that Canyon offers*
*to procedurally generate comparation operators for the queries.*

Inside the function definition, we will write the logic to find by id a unique record inside
some database table. The function could be called like:

`find_by_id(LeagueFieldValue::id(1)).await;`

That's not the way of how `Canyon's` creates the `SQL` filters, but we hope that reflects
the way that we decided that we need to offer some procedural way to identify columns.

The call above will generate the following `SQL where clause`:
`WHERE league.id = 1`


## In sumary

We know now about the `canyon_entity` macro, how it works an for what reason was designed.
We also learned about the two autogenerated enumerations to make our code much more robust
and less error prone using procedures instead of literals.

But we know that you must be a little bit confusing with this information, because, where
do we apply it? How do we really generate those filters?

The answer it's with the `Canyon` `QueryBuilder`, and it's time to meet it.
See you in the next chapter!

