# Canyon Entity

Woo! Time to get serious!

We are gonna review one of the most iconic of the `Canyon` features. *The entities*

## What is a Canyon Entity?

You already see how, in the past chapters, we defined the concept of entity and
how it was used in a lot of contexts.

But in `Canyon` an *entity* still has a powerful meaning that the presented before.

Let's start simple. A `Canyon Entity` it's a user defined type, a struct, that
it's annotated with a really special `proc-macro`.

`#[canyon_entity]`

It looks like this attached to our `League` example for the past chapters:

```rust
use canyon_sql::macros::canyon_entity;

#[canyon_entity]
pub struct League {
    #[primary_key]
    pub id: i32,
    pub ext_id: i64,
    pub slug: String,
    pub name: String,
    pub region: String,
    pub image_url: String
}
```

This macro unlocks a set of new features to our type. But, how this affect you? Why is so special?

This annotation makes two important things for you:

- Let to `Canyon` knows that you desire that it should take care about
everything in your program related with this type
- Tracks it in a special register, with all the metadata needed
- Let you configure an alternative table name and let's you specify the schema where entity that is being pointed lives.

Those are only three things, but the implications behind them are really huge for the upcoming lectures. But for now, let's gonna discuss the second point to discover something new about `Canyon` and to prepare ourselves for the next chapter.

## The `table_name` and the `schema` attribute parameter

The `canyon_entity` macro optionally receives two parameters.
`#[canyon_entity(table_name = "other_league", schema = "tic" )]`

Usually, the convention within `Canyon` is to convert your struct's name to a snake case identifier
for the generated operations. This allows you to not have to modify anything different than the defaults, and follow the typical ORM conventions along with the most used way of defining a table
name between the different engines.

But that's not has to be the case always. Sometimes, your tables already exists in the database, and you need other mapping, or even better, you want to use a different name in your *Rust* struct that doesn't fits into the direct convertion to snake case presented above. So you can specify the name of the database entity that you want to relate with your type.

Also, Canyon assumes that your entities will be placed in the default schema. For example, `public` in `PostgreSQL` or `dbo` in `MSSQL`. And could be the case that you need to use and alternative schema. Well, this is configurable per entity with the parameters showed above.

## The #[primary_key] field attribute

Let's review one of the most important concepts in relational databases. The `primary_key`.
Each table within a database will typically have its own primary key. The main purpose of designating a primary key is to identify each unique record in a particular table.

Within `Canyon`, it's a very big thing. Every entity must be (almost always) annotated with a `primary_key`. This let's you unlock the full potential of the `CRUD` operations generated by the `CanyonCrud` derive macro. Also, it handles another things, like data-serialization or the automatic mapping with the autogenerated unique autoincremental new value for that column after an insert operation, putting that new value directly in your instance.

It has one optional parameter: `autoincremetal`. Sometimes you don't have an incremental primary key,
or you don't want your id to be autoincremental (typically, on rare text columns that acts as a kind of primary key). This is not really common, but is allowed, and sometimes used. So we offer the oportunity to set the `primary_key` annotation as *NOT* autoincremental, by just writting:
`#[primary_key(autoincremental = false)]`

Note that it's default value is `#[primary_key(autoincremental = true)]`, so this lets you write only the field annotation: `#[primary_key]`

So, unless you've already have a table that uses compound primary keys or text columns that looks like primary keys, remeber to annotate your `primary_key` column with the `#[primary_key]` annotation.
