# The QueryBuilder

`Canyon` has a powerful querybuilder.

Until now, queries are executed by mapping fields and the data of the fields
for every type or instance of that type.

But `SQL` offers a lot of more power to analyze and manipulate the data stored in its tables.
We are concretly talking now about the `SQL Clauses` that acts like filters.

`Canyon` provides support for make the queries over your entities more flexible. They're also
defined in the `CanyonCrud` macro. Currently, we are supporting the following ones:
- `WHERE`
- `AND`
- `IN`
- `ORDER BY`
- `SET`

The latest one it's a special one clause. It's the `SET` SQL clause used in the `UPDATE`
statements to define what columns will be updated. It only works with the update methods.
Using it in another one will make your code panic, so be careful with the wrong usage.


## How does it works?

Every associated function or method provided through the macro implementations
that returns a `QueryBuilder` type can be used as a builder pattern to construct
the query that Canyon will use to retrive data from the database. Those associated
functions or methods contains a `_query` in its identifier, which basically it's 
telling your: *Hey, I will give you a QueryBuilder when you call me*

To start to meet it, let's review its type signature:
```
pub struct QueryBuilder<'a, T: Debug + CrudOperations<T> + Transaction<T> + RowMapper<T>> { /* fields */ }
```
*Reviewing the signature of the QueryBuilder<T> type*

As it's name suggests, the `QueryBuilder` it's just an implementation of the *Builder*
dessign pattern, and here in `Canyon` it's used to build a `Query` type, which it's the final
responsable to execute the generated `SQL` after the use of our builder.

The `QueryBuilder` works by first, generate the base `SQL` as the rest of the `CRUD` operations
presented in the past chapters. But, instead of executing the query, it lets you to chain
methods over a `QueryBuilder` instance that, for every method call, generates more `SQL` content 
for your query, depending what method you call.


## Available methods to work with the builder

You can *chain* call over your `QueryBuilder` to build a more complex query when you need it.
Every method will return `Self` to make you able to aggregate and modify your query according
to your needs. By returning `Self`, we make access to the same instance of the `QueryBuilder`,
modifying it's internal state until it's consumed.

To start to see what the `QueryBuilder` it's capable to do, let's review
the available methods (related to the SQL clauses) with it's signatures are:

- `WHERE`    -> `pub fn where_clause<Z: FieldValueIdentifier>(mut self, r#where: Z, comp: Comp) -> Self`
- `AND`      -> `pub fn and_clause<Z: FieldValueIdentifier>(mut self, r#and: Z, comp: Comp) -> Self`
- `IN`       -> `pub fn r#in(mut self, in_values: &'a[Box<dyn InClauseValues>]) -> Self`
- `ORDER BY` -> `pub fn order_by<Z: FieldIdentifier>(mut self, order_by: Z, desc: bool) -> Self`

*NOTE: If you miss the 'LIKE' clause, don't worry. It will be released soon.*

That's will make you and idea on what the chained methods do over the instance. It really
just appends more `SQL` code to the base one, to filter the results that you potencially
could desire because some business requeriment.


# The Comp enum type

The `QueryBuilder` usually works receiving in some methods a comparation operator. 
In `Canyon` it's created from the `Comp` enum type, which it's received by parameter
by the methods that required them, and allows you to generate comparation operators
in a procedural way.

This is the available ones:

```
pub enum Comp {
    Eq,  => "="   // Equals to
    Neq, => <>"   // Not equals to 
    Gt,  => ">"   // Greather than
    Gte, => ">="  // Greater or equals than
    Lt,  => "<"   // Less than
    Lte, => "<="  // Less or equals than
}
```


# Better by example

We know that it could be confusing how the `QueryBuilder` works, essentially if you not
fight too often with `Builders`, but, wait... probably you will use it a lot!

Let's put an use case, working with our beloved `League` type: We want to recover
all the `league` table records which `id` are less than 20 and it's `slug` it is
equals to `LCK`.

```
let leagues: Option<Vec<League>> = League::find_all_query()
        .where_clause(
            LeagueFieldValue::id(20),    // This will create a filter -> `WHERE league.id < 20`
            Comp::Lt                     // where the `<` symbol it's generated by Canyon when sees this variant
        ).and(
            LeagueFieldValue::slug("LCK".to_string()),
            Comp::Eq
        ).query()
        .await
        .ok();                           // No error handling here. Consumes the result and converts a Result<T> to an Option<T>

println!("League elements QUERYBUILDER: {:?}", &leagues);
```

The rest of methods that you may desire to chain are trivial. You can chain as many as you need, but
obviously, try to use those one who makes sense for your queries.


## The 'consumer' concept

Execute the query it's really simple as demostrated above. Just `.query()` when you're satisfied
with the `SQL` that will be generated. Then `.await` it and you're done. Use the `Result` returned
to avoid the compiler warn you about to not handle the posible error after execute the query.

*NOTE: We're here okeying the result. You may desire to provide a better handle implementation*
*but, for the tutorial purposes, is enought.*

Every builder object built with the `Builder` pattern must provide a consumer or not (other implementations
are outside the scope of this tutorial), but in `Canyon`, when you want to execute the generated `SQL`, 
you only need to call the consumer of the builder. The `.query()` method.

The consumer here basically just consumes `self` and executes the query, returning you a 
`Result<Vec<T>, Error>` with the results obtained from the database for your type `T`.


## Where to find _query methods?

To summarize, `Canyon` currently has implementations for the following CRUD operations:

- Find by id 
- Multiple insert
- Update multiple columns
- Delete

Every one of this are implemented as an associated functions. It does not makes sense, because
you can perform data modifications over various instances at a time, or you want to delete from
the database data that you know that exists, but don't want to generate instances for make a 
`.delete()` method call on every one, being potentially inneficient if a lot of data has to
be deleted (because it w'd be one query per method call), and same for the *multi* operations.

This way, we're decoupling the data from the `Canyon` entities, giving the developer more power
in case if need it, and reducing the posible overheat of working with mapped to entities components
only.

In the `multi insert` and the `update multiple columns`, we're working with entity instances but just to be 
passed as arguments.
The operations will be performed in only one query no matter how data you want to insert or update, so our
function arquitechture it's based on calls to the type `T` via associated functions.

So, the unique overheat here it's the database server efficiency working in this way, not
an implementation detail in your code.


## Multi insert and update multiple columns

Just for having a notion of what's going on with those two options that `Canyon` offers you,
let's see an example of every one to let your clear how to write yourselves.

The purpose of the `multi insert` it's to allow you to insert multiple entities in just
one query, avoiding you to make a method call for every one or writting a loop for it.

```
    let new_league = League {
        id: Default::default(),
        ext_id: 392489032,
        slug: "League10".to_owned(),
        name: "League10also".to_owned(),
        region: "Turkey".to_owned(),
        image_url: "https://www.sdklafjsd.com".to_owned()
    };
    let new_league2 = League {
        id: Default::default(),
        ext_id: 392489032,
        slug: "League11".to_owned(),
        name: "League11also".to_owned(),
        region: "LDASKJF".to_owned(),
        image_url: "https://www.sdklafjsd.com".to_owned()
    };
    let new_league3 = League {
        id: Default::default(),
        ext_id: 9687392489032,
        slug: "League3".to_owned(),
        name: "3League".to_owned(),
        region: "EU".to_owned(),
        image_url: "https://www.lag.com".to_owned()
    };

    League::insert_multi(
        &[new_league, new_league2, new_league3]
    ).await
    .ok();
```
*Multi insert into the 'league' table example*


The `update multiple columns` it's a real `QueryBuilder` operation.
It just simply works by setting the values of the provided columns (via FieldIdentifier item)
to the values provided in the special `SET` clause.

`SET` clause arguments are a little bit tricky. It will accept a reference to an
array of tuples, being every tuple compound of a `FieldIdentifier` item and `ToString` item.

Any thing that implements `FieldIdentifier` at the `.0` position, and anything that implements
`ToString` at the `.1` position of the tuple passed in.

*NOTE: You can pass any value that implements ToSql + Sync, so you can pass an i32, a bool...*
*Canyon will automatically convert what he needs to make the query works as expected.*

```
    League::update_query()
        .set_clause(
            &[
                (LeagueField::ext_id, 394039),
                (LeagueField::image_url, "https://random_updated_url.up")
            ]
        ).where_clause(
            LeagueFieldValue::id(3), Comp::Gt
        ).query()
        .await
        .ok();
```
*Updating multiple columns with Canyon at the same time*